use std::{collections::HashMap, fmt::Debug};

pub use semver::Version;

use crate::blockchain_data::BlockchainData;
use crate::{
    daemon::{assembly_script::AssemblyScriptExecutor, incident::Incident, sql::SqlExecutor},
    BlockchainCtx, DataError, IncidentData,
};

pub mod assembly_script;
pub mod incident;
pub mod sql;

#[derive(Debug)]
pub struct VerifyCtx {
    /// Do daemon found any incidents.
    pub matched: bool,

    /// Incidents generated by the daemon expression.
    pub incidents: Vec<Incident>,
}

/// The parameters that are passed to Daemon.
pub type DaemonParameters = HashMap<String, String>;

/// The versions of the dependencies that are passed to Daemon.
pub type DaemonVersions = HashMap<String, Version>;

#[derive(Debug)]
pub enum Executor {
    Sql(SqlExecutor),
    AssemblyScript(AssemblyScriptExecutor),
}

/// The Daemon entity.
#[derive(Debug)]
pub struct Daemon {
    id: String,
    executor: Executor,
}

impl Daemon {
    pub const MAMORU_VERSION_KEY: &'static str = "mamoru";

    pub fn new_sql(
        id: String,
        expression: &str,
        incident_data: IncidentData,
        parameters: DaemonParameters,
        versions: HashMap<String, Version>,
    ) -> Result<Self, DataError> {
        let version = versions
            .get(Self::MAMORU_VERSION_KEY)
            .cloned()
            .unwrap_or_else(|| "0.0.0".parse().expect("0.0.0 is a valid version."));

        let executor = Executor::Sql(SqlExecutor::new(
            expression,
            incident_data,
            parameters,
            version,
        )?);

        Ok(Self::new(id, executor))
    }

    pub fn new_assembly_script(
        id: String,
        wasm: impl AsRef<[u8]>,
        parameters: DaemonParameters,
        versions: HashMap<String, Version>,
    ) -> Result<Self, DataError> {
        let executor =
            Executor::AssemblyScript(AssemblyScriptExecutor::new(wasm, parameters, versions)?);

        Ok(Self::new(id, executor))
    }

    pub fn new(id: String, executor: Executor) -> Self {
        Self { id, executor }
    }

    pub fn id(&self) -> String {
        self.id.clone()
    }

    /// Executes the given daemon.
    #[tracing::instrument(skip_all, fields(daemon_id = %self.id()))]
    pub async fn verify<T: BlockchainCtx>(
        &self,
        ctx: &BlockchainData<T>,
    ) -> Result<VerifyCtx, DataError> {
        let incidents = match &self.executor {
            Executor::Sql(sql) => sql.execute(ctx).await?,
            Executor::AssemblyScript(ass) => ass.execute(ctx).await?,
        };

        Ok(VerifyCtx {
            matched: !incidents.is_empty(),
            incidents,
        })
    }
}
