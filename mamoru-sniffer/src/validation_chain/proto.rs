pub mod validation_chain {
    pub use super::includes::validationchain::validationchain::*;
}

pub mod cosmos {
    pub use super::includes::hack::TxMsgData;
    pub use cosmrs::proto::cosmos::*;
}

mod includes {
    // Disable Clippy for autogenerated code.
    #![allow(clippy::all)]

    tonic::include_proto!("includes");
}

use crate::validation_chain::{
    proto::validation_chain::{value::Kind, DaemonMetadataContentType, ListValue, Struct, Value},
    ChainType, DaemonParameter, DaemonQueryResponseDto, IncidentSeverity,
};
use mamoru_core::{Daemon, IncidentData, IncidentDataStruct, IncidentDataValue};
use serde::{Deserialize, Deserializer};
use std::str::FromStr;
use strum::VariantNames;
use tracing::{error, warn};

impl From<DaemonQueryResponseDto> for Vec<Daemon> {
    fn from(value: DaemonQueryResponseDto) -> Self {
        let metadata = value.daemon_metadata.expect("BUG: Missing DaemonMetadata.");
        let content = metadata
            .content
            .expect("BUG: Missing DaemonMetadataContent.");

        match content.r#type() {
            DaemonMetadataContentType::Sql => content
                .query
                .into_iter()
                .filter_map(|query| {
                    let incident_data = IncidentData {
                        message: query.incident_message.clone(),
                        severity: query.severity().into(),
                    };

                    match Daemon::new_sql(value.daemon_id.clone(), &query.query, incident_data) {
                        Ok(daemon) => Some(daemon),
                        Err(err) => {
                            error!(?err, %value.daemon_id, "Failed to parse SQL daemon.");

                            None
                        }
                    }
                })
                .collect(),
            DaemonMetadataContentType::Wasm => {
                let wasm_bytes = match base64::decode(&content.wasm_module) {
                    Ok(wasm_bytes) => wasm_bytes,
                    Err(err) => {
                        error!(?err, %value.daemon_id, "Failed to decode WASM base64-encoded payload.");

                        return vec![];
                    }
                };
                let parameters = make_daemon_parameters(value.parameters);

                match Daemon::new_assembly_script(value.daemon_id.clone(), wasm_bytes, parameters) {
                    Ok(daemon) => vec![daemon],
                    Err(err) => {
                        error!(?err, %value.daemon_id, "Failed to parse WASM daemon.");

                        vec![]
                    }
                }
            }
        }
    }
}

impl From<IncidentSeverity> for mamoru_core::IncidentSeverity {
    fn from(value: IncidentSeverity) -> Self {
        match value {
            IncidentSeverity::SeverityInfo => Self::Info,
            IncidentSeverity::SeverityWarning => Self::Warning,
            IncidentSeverity::SeverityError => Self::Error,
            IncidentSeverity::SeverityAlert => Self::Alert,
        }
    }
}

impl From<IncidentDataStruct> for Struct {
    fn from(value: IncidentDataStruct) -> Self {
        Struct {
            fields: value
                .fields()
                .into_iter()
                .map(|(key, value)| (key, value.into()))
                .collect(),
        }
    }
}

impl From<IncidentDataValue> for Value {
    fn from(value: IncidentDataValue) -> Self {
        let kind = match value {
            IncidentDataValue::Null => Kind::NullValue(0),
            IncidentDataValue::Number(number) => Kind::NumberValue(number),
            IncidentDataValue::String(string) => Kind::StringValue(string),
            IncidentDataValue::Bool(bool) => Kind::BoolValue(bool),
            IncidentDataValue::Struct(struct_) => Kind::StructValue((*struct_).into()),
            IncidentDataValue::List(list) => Kind::ListValue(ListValue {
                values: list.into_iter().map(Into::into).collect(),
            }),
        };

        Value { kind: Some(kind) }
    }
}

fn make_daemon_parameters(values: Vec<DaemonParameter>) -> mamoru_core::DaemonParameters {
    let mut results = mamoru_core::DaemonParameters::new();

    for parameter_dto in values {
        if results.get(&parameter_dto.key).is_some() {
            warn!(key = %parameter_dto.key, "Duplicate daemon parameter key");
        } else {
            results.insert(parameter_dto.key, parameter_dto.value);
        }
    }

    results
}

impl<'de> Deserialize<'de> for ChainType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let chain_name = String::deserialize(deserializer)?;

        ChainType::from_str(&chain_name).map_err(|_| {
            serde::de::Error::custom(format!(
                "Failed to parse chain type. Given: {}, Available: [{}]",
                chain_name,
                ChainType::VARIANTS.join(", ")
            ))
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn chain_type_from_str() {
        let chain = ChainType::from_str("SUI_DEVNET").unwrap();

        assert!(matches!(chain, ChainType::SuiDevnet))
    }

    #[derive(Deserialize)]
    struct TestObject {
        chain: ChainType,
    }

    #[test]
    fn chain_type_from_serde() {
        let object: TestObject = serde_json::from_str("{\"chain\":\"SUI_DEVNET\"}").unwrap();

        assert!(matches!(object.chain, ChainType::SuiDevnet))
    }
}
