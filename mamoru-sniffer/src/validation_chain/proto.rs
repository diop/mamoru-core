pub mod validation_chain {
    pub use super::includes::validationchain::validationchain::*;
}

pub mod cosmos {
    pub use cosmrs::proto::cosmos::*;
}

mod includes {
    // Disable Clippy for autogenerated code.
    #![allow(clippy::all)]

    tonic::include_proto!("includes");
}

use crate::errors::DaemonParseError;
use crate::validation_chain::{ChainType, DaemonQueryResponseDto};
use mamoru_core::Daemon;
use serde::{Deserialize, Deserializer};
use std::str::FromStr;

impl TryFrom<DaemonQueryResponseDto> for Daemon {
    type Error = DaemonParseError;

    fn try_from(value: DaemonQueryResponseDto) -> Result<Self, Self::Error> {
        let daemon = Self::new_sql(
            value.daemon_id,
            &value.daemon_metadata.unwrap().content.unwrap().query[0]
                .clone()
                .query,
        )?;

        Ok(daemon)
    }
}

impl<'de> Deserialize<'de> for ChainType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let chain_name = String::deserialize(deserializer)?;

        ChainType::from_str(&chain_name).map_err(serde::de::Error::custom)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn chain_type_from_str() {
        let chain = ChainType::from_str("SUI_DEVNET").unwrap();

        assert!(matches!(chain, ChainType::SuiDevnet))
    }

    #[derive(Deserialize)]
    struct TestObject {
        chain: ChainType,
    }

    #[test]
    fn chain_type_from_serde() {
        let object: TestObject = serde_json::from_str("{\"chain\":\"SUI_DEVNET\"}").unwrap();

        assert!(matches!(object.chain, ChainType::SuiDevnet))
    }
}
