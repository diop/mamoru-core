pub mod validation_chain {
    pub use super::includes::validationchain::validationchain::*;
}

pub mod cosmos {
    pub use cosmrs::proto::cosmos::*;
}

mod includes {
    // Disable Clippy for autogenerated code.
    #![allow(clippy::all)]

    tonic::include_proto!("includes");
}

use crate::errors::RuleParseError;
use crate::validation_chain::{ChainType, DaemonQueryResponseDto};
use chrono::DateTime;
use mamoru_core::Rule;
use serde::{Deserialize, Deserializer};
use std::str::FromStr;

impl TryFrom<DaemonQueryResponseDto> for Rule {
    type Error = RuleParseError;

    fn try_from(value: DaemonQueryResponseDto) -> Result<Self, Self::Error> {
        let activate_since = DateTime::parse_from_rfc3339(&value.activate_since)
            .map_err(RuleParseError::DateTime)?
            .timestamp();
        let inactivate_since = DateTime::parse_from_rfc3339(&value.inactivate_since)
            .map_err(RuleParseError::DateTime)?
            .timestamp();

        let rule = Self::new(
            value.daemon_id,
            activate_since,
            inactivate_since,
            &value.content,
        )?;

        Ok(rule)
    }
}

impl<'de> Deserialize<'de> for ChainType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let chain_name = String::deserialize(deserializer)?;

        ChainType::from_str(&chain_name).map_err(serde::de::Error::custom)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn chain_type_from_str() {
        let chain = ChainType::from_str("SUI_DEVNET").unwrap();

        assert!(matches!(chain, ChainType::SuiDevnet))
    }

    #[derive(Deserialize)]
    struct TestObject {
        chain: ChainType,
    }

    #[test]
    fn chain_type_from_serde() {
        let object: TestObject = serde_json::from_str("{\"chain\":\"SUI_DEVNET\"}").unwrap();

        assert!(matches!(object.chain, ChainType::SuiDevnet))
    }
}
