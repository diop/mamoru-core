pub mod validation_chain {
    pub use super::includes::validationchain::validationchain::*;
}

pub mod cosmos {
    pub use super::includes::hack::TxMsgData;
    pub use cosmrs::proto::cosmos::*;
}

mod includes {
    // Disable Clippy for autogenerated code.
    #![allow(clippy::all)]

    tonic::include_proto!("includes");
}

use crate::validation_chain::proto::validation_chain::DaemonMetadataContentType;
use crate::validation_chain::{ChainType, DaemonParameter, DaemonQueryResponseDto};
use mamoru_core::Daemon;
use serde::{Deserialize, Deserializer};
use std::str::FromStr;
use strum::VariantNames;
use tracing::{error, warn};

impl From<DaemonQueryResponseDto> for Vec<Daemon> {
    fn from(value: DaemonQueryResponseDto) -> Self {
        let metadata = value.daemon_metadata.expect("BUG: Missing DaemonMetadata.");
        let content = metadata
            .content
            .expect("BUG: Missing DaemonMetadataContent.");

        let content_type = match DaemonMetadataContentType::from_i32(content.r#type) {
            Some(content_type) => content_type,
            None => {
                error!(%value.daemon_id, content_type = content.r#type, "Received unsupported `DaemonMetadataContentType`.");

                return vec![];
            }
        };

        match content_type {
            DaemonMetadataContentType::Sql => content
                .query
                .into_iter()
                .filter_map(
                    |query| match Daemon::new_sql(value.daemon_id.clone(), &query.query) {
                        Ok(daemon) => Some(daemon),
                        Err(err) => {
                            error!(?err, %value.daemon_id, "Failed to parse SQL daemon.");

                            None
                        }
                    },
                )
                .collect(),
            DaemonMetadataContentType::Wasm => {
                let wasm_bytes = match base64::decode(&content.wasm_module) {
                    Ok(wasm_bytes) => wasm_bytes,
                    Err(err) => {
                        error!(?err, %value.daemon_id, "Failed to decode WASM base64-encoded payload.");

                        return vec![];
                    }
                };
                let parameters = make_daemon_parameters(value.parameters);

                match Daemon::new_assembly_script(value.daemon_id.clone(), wasm_bytes, parameters) {
                    Ok(daemon) => vec![daemon],
                    Err(err) => {
                        error!(?err, %value.daemon_id, "Failed to parse WASM daemon.");

                        vec![]
                    }
                }
            }
        }
    }
}

fn make_daemon_parameters(values: Vec<DaemonParameter>) -> mamoru_core::DaemonParameters {
    let mut results = mamoru_core::DaemonParameters::new();

    for parameter_dto in values {
        if results.get(&parameter_dto.key).is_some() {
            warn!(key = %parameter_dto.key, "Duplicate daemon parameter key");
        } else {
            results.insert(parameter_dto.key, parameter_dto.value);
        }
    }

    results
}

impl<'de> Deserialize<'de> for ChainType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let chain_name = String::deserialize(deserializer)?;

        ChainType::from_str(&chain_name).map_err(|_| {
            serde::de::Error::custom(format!(
                "Failed to parse chain type. Given: {}, Available: [{}]",
                chain_name,
                ChainType::VARIANTS.join(", ")
            ))
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn chain_type_from_str() {
        let chain = ChainType::from_str("SUI_DEVNET").unwrap();

        assert!(matches!(chain, ChainType::SuiDevnet))
    }

    #[derive(Deserialize)]
    struct TestObject {
        chain: ChainType,
    }

    #[test]
    fn chain_type_from_serde() {
        let object: TestObject = serde_json::from_str("{\"chain\":\"SUI_DEVNET\"}").unwrap();

        assert!(matches!(object.chain, ChainType::SuiDevnet))
    }
}
